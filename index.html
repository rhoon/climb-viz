<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
        <div class="rockwall one">
            <svg id="limblines"></svg>
        </div>
        <div class="rockwall two"></div>

        <div id="leftside">

            <ul class="datalist">
                <lh>
                    <span class="timestamp col-1">Timestamp</span>
                    <span class="movement col-2">Movement</span>
                </lh>
            </ul>

            <svg id="timeline"></div>

        </div>

    </div>

    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">

    <script>
    // dynamically size everything according to the window size
    let svg = d3.select("#limblines"),
        timeline = d3.select("#timeline"),
        background1 = d3.selectAll("div.rockwall.one"),
        background2 = d3.selectAll("div.rockwall.two"),
        datalist = d3.select("ul.datalist"),
        window_width = window.innerWidth,
        window_height = window.innerHeight,
        img_width = 1001,
        height = window_height,
        img_height = 2017,
        resize_ratio = (height / img_height),
        width = img_width*resize_ratio;
        data_loaded = null;
        limbs = ['RH', 'LH', 'RF', 'LF'];


    svg.attr("width", (width+"px"));
    svg.attr("height", (height+"px"));

    background1.style("width", (width+"px"));
    background1.style("height", (height+"px"));
    background1.style("right", (0+"px"));
    background2.style("width", (width+"px"));
    background2.style("height", (height+"px"));

    // TIMELINE set-up
    timeline.style("height", (height+"px"));
    const margin = {
        top: 0,
        right: 10,
        bottom: 0,
        left: 10
    }

    // make strings numbers
    function n(d) {
        return Number(d);
    }

    d3.csv("data/20201108_export.csv", function(error, data) {
      if (error) throw error;

      data_loaded = data;

      console.log(data);

      // TIMELINE / HORIZONTAL BAR CHART - ref: https://observablehq.com/@d3/horizontal-bar-chart

      x = d3.scaleLinear()
          .domain([0, d3.max(data, function(d) {
            let dist = getDistance(d, false);
            return dist;
          })])
          .range([margin.left, parseInt(timeline.style("width"))-margin.right ])

      y = d3.scaleBand()
        .domain(d3.range(data.length))
        .rangeRound([0, height])
        .padding(0.1)

      let barHeight = height/data.length;

      let barGroup = timeline.selectAll("g")
        .data(data)
        .enter()
        .append("g")
        .classed("bar_group", true);

      barGroup.append("rect")
        .attr("x", x(0))
        .attr("y", function(d, i) {
            return y(i);
        })
        .attr("width", parseInt(timeline.style("width"))-margin.right)
        .attr("height", barHeight)
        .attr("class", function(d, ix) {
            return "barback onion d"+ix;
        })

      barGroup.append("rect")
        .attr("x", x(0))
        .attr("y", function(d, i) {
            return y(i);
        })
        .attr("width", function(d) {
            let dist = getDistance(d, false);
            console.log(dist);
            return x(dist) - x(0);
        })
        .attr("height", barHeight/2);


      // DATALIST - list data and provide main UI

      let datalistItem = datalist.selectAll('li')
            .data(data)
            .enter()
            .append('li')
            .on('mouseover', function(d, i) {
                onionSkin(i);
            });

      datalistItem.append('span')
            .classed('timestamp col-1', true)
            .text( function(d) {
                return formatTime(d.Timestamp_Minutes)
            });

      let datalistMovement = datalistItem.append('div')
            .classed('movement col-2', true);

      datalistMovement.append('span')
            .text( function(d) {

                let limbMoved = whichLimbMoved(d);

                if (limbMoved === null) {
                    console.log('warning: ')
                    console.log(d);
                }

                return (limbMoved != null) ? formatLimb(limbMoved) : 'Not available';
            });

      datalistMovement.append('div')
            .classed('arrow', true)
            .style('transform', function(d, i) {
                let limbMoved = whichLimbMoved(d);
                let x = n(d[limbMoved+'_X_Delta']);
                let y = n(d[limbMoved+'_Y_Delta']);

                let degrees = (-1)*(Math.atan(x / y)*(180/Math.PI)).toFixed(2);
                return 'rotate('+degrees+'deg)';
            });

      datalistMovement.append('span')
            .classed('distance', true)
            .html( function(d) {
                return getDistance(d, true);
            });

      // CREATE ROUTE MAP AND DYNAMIC COMPOSITE

      background2.on('mouseover', function() {
          d3.selectAll('.onion').transition().duration(200).style('opacity', 1);
      })

      // add the images of logan climbing the wall
      background2.selectAll('img.position')
            .data(data)
            .enter()
            .append('img')
            .attr('class', function(d, i) {
                return 'position onion d'+i;
            })
            .style('top', function(d) {
                return (d.Img_Pos_Y_px*resize_ratio)+'px';
            })
            .style('left', function(d) {
                return (d.Img_Pos_X_px*resize_ratio)+'px';
            })
            .style('width', function(d) {
                return (d.Img_Width_px*resize_ratio)+'px';
            })
            .style('height', function(d) {
                return (d.Img_Height_px*resize_ratio)+'px';
            })
            .style('z-index', function(d, i) {
                return 120-i;
            })
            .attr('src', function(d, i) {
                return 'images/sequence_4/'+(119-i)+'.png';
            });


      // interate through each set of limbs and draw a corresponding line
      for (var i in limbs) {

          // get pixel-value positions
          function x_pos(d) {
              return n( d[limbs[i]+'_X'] )*resize_ratio;
          }

          function y_pos(d) {
              return n( d[limbs[i]+'_Y'] )*resize_ratio;
          }

          function x_delta(d) {
              return n( d[limbs[i]+'_X_Delta'] )*resize_ratio;
          }

          function y_delta(d) {
              return n( d[limbs[i]+'_Y_Delta'] )*resize_ratio;
          }

          let line = svg.selectAll('line.'+limbs[i])
            .data(data)
            .enter()
            .append('line')
            .attr('class', function(d, ix) {
                return limbs[i]+' onion d'+ix;
            })
            .attr('x1', function(d) {
                return x_pos(d);
            })
            .attr('x2', function(d) {
                return ( x_pos(d) - x_delta(d) );
            })
            .attr('y1', function(d) {
                return y_pos(d);
            })
            .attr('y2', function(d) {
                return ( y_pos(d) - y_delta(d) );
            });

          let circle = svg.selectAll('circle.'+limbs[i])
            .data(data)
            .enter()
            .append('circle')
            .attr('cx', function(d) {
                return x_pos(d);
            })
            .attr('cy', function(d) {
                return y_pos(d);
            })
            .attr('r', 2)
            .attr('class', function(d , ix) {
                return 'onion d'+ix;
            });
      }

    });

    function getDistance(d, format) {

        let limbMoved = whichLimbMoved(d);

        // limb moved returns null if 0s
        if ( limbMoved != null ) {

            let x = n(d[limbMoved+'_X_Delta']);
            let y = n(d[limbMoved+'_Y_Delta']);

            return format ? formatDistance(x, y, n(d['Pixel_Foot'])) : calcDistance(x, y, n(d['Pixel_Foot']));

        }   else {

            return format ? 0+"&prime; "+0+"&Prime;" : 0;
        }

    }

    function formatTime(rawTime) {
        // input is formatted as minutes in decimal (eg 3.456)
        // converts decimal place to seconds and formats to standard display (12:00)
        let minutes = Math.floor(rawTime);
        let seconds = rawTime - minutes;
            seconds = Math.round((seconds*60), 0);
            seconds = seconds<10 ? '0'+seconds : seconds;

        return minutes + ':' + seconds;
    }

    function formatLimb(limb) {

        switch (limb) {
            case 'RF':
                limbText = "Right Foot";
                break;
            case 'LF':
                limbText = "Left Foot";
                break;
            case 'RH':
                limbText = "Right Hand";
                break;
            case 'LH':
                limbText = "Left Hand";
                break;
        }

        return limbText;

    }

    function calcDistance(x, y, pixelFoot) {

        x = Math.abs(x);
        y = Math.abs(y);
        let dist = Math.sqrt(Math.pow(x, 2)+Math.pow(y, 2));
            dist = dist/pixelFoot;

        return dist;
    }

    function formatDistance(x, y, pixelFoot) {

        let dist = calcDistance(x, y, pixelFoot);

        let feet = Math.floor(dist);

        let inches = dist - feet;
            inches = Math.round((inches*12), 0);

        return feet+'&prime; '+inches+'&Prime;';

    }

    function whichLimbMoved(d) {

        let limbMoved = null;

        // which appendage moved? The one with a delta not equal to zero
        limbs.forEach( function(limb, limb_index) {
            if (n(d[limb+'_X_Delta']) != 0  ||  n(d[limb+'_Y_Delta']) != 0) {
                limbMoved = limb;
            }
        });

        return limbMoved;
    }

    // current height is the distance of the lowest foot from the ground
    function currentHeight(d) {

        // get the position of the lowest limb
        let lowerLimbPos = d.LF_Y > d.RF_Y ? d.LF_Y : d.RF_Y;
        let heightFromGround = (real_height - lowerLimbPos)/d.Pixel_Foot;
        return heightFromGround.toFixed(2);

    }


    function onionSkin(ix) {

        // select all . set opacity to 0
        let all = d3.selectAll('.onion');
        all.style('opacity', 0);

        // select ix +- 5 set opacity to 10
        d3.selectAll('.d'+(ix+4)).style('opacity', 0.1);
        d3.selectAll('.d'+(ix-4)).style('opacity', 0.1);
        // select ix +- 4 set opacity to 20
        d3.selectAll('.d'+(ix+3)).style('opacity', 0.2);
        d3.selectAll('.d'+(ix-3)).style('opacity', 0.2);
        // select ix +- 3 set opacity to 30
        d3.selectAll('.d'+(ix+2)).style('opacity', 0.3);
        d3.selectAll('.d'+(ix-2)).style('opacity', 0.3);
        // select ix +- 2 set opacity to 40
        d3.selectAll('.d'+(ix+1)).style('opacity', 0.4);
        d3.selectAll('.d'+(ix-1)).style('opacity', 0.4);
        // select ix +- 1 set opacity to 50
        d3.selectAll('.d'+(ix)).style('opacity', 1);
        // select ix, set opacity to 100

    }

    </script>
</body>
