<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <!-- <script src="node_modules/lib/animated-scroll-to.js"></script> -->


</head>
<body>
        <div class="rockwall one">
            <svg id="limblines"></svg>
        </div>
        <div class="rockwall two"></div>

        <div id="leftside">

            <div id="nav">
                <a href="#" id="climb">Climb</a>
                <a href="#" id="about">About</a>
                <a href="#" id="process">Process</a>
                <a href="#" id="cpright">&copy; 2020 Riley Hoonan</a>
            </div>

            <div class="header">Movement</div>

            <div class="header">Distance</div>

            <ul id="datalist"></ul>

            <svg id="timeline"></div>

        </div>

    </div>

    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">

    <script>
    // dynamically size everything according to the window size
    let svg = d3.select("#limblines"),
        timeline = d3.select("#timeline"),
        background1 = d3.selectAll("div.rockwall.one"),
        background2 = d3.selectAll("div.rockwall.two"),
        datalist = d3.select("ul#datalist"),
        window_width = window.innerWidth,
        window_height = window.innerHeight,
        img_width = 1001,
        height = window_height,
        img_height = 2017,
        resize_ratio = (height / img_height),
        width = img_width*resize_ratio;
        data_loaded = null;
        limbs = ['RH', 'LH', 'RF', 'LF'];


    svg.attr("width", (width+"px"));
    svg.attr("height", (height+"px"));

    background1.style("width", (width+"px"));
    background1.style("height", (height+"px"));
    background1.style("right", (0+"px"));
    background2.style("width", (width+"px"));
    background2.style("height", (height+"px"));

    // TIMELINE set-up
    timeline.style("height", (height+"px"));


    const margin = {
        top: 0,
        right: 10,
        bottom: 0,
        left: 0
    }

    // make strings numbers
    function n(d) {
        return Number(d);
    }

    d3.csv("data/20201108_export.csv", function(error, data) {
      if (error) throw error;

      data_loaded = data;

      console.log(data);

      // TIMELINE / HORIZONTAL BAR CHART - ref: https://observablehq.com/@d3/horizontal-bar-chart

      x = d3.scaleLinear()
          .domain([0, d3.max(data, function(d) {
            let dist = getDistance(d, false);
            return dist;
          })])
          .range([margin.left, parseInt(timeline.style("width"))-margin.right ])

      y = d3.scaleBand()
        .domain(d3.range(data.length))
        .range([0, height])
        .padding(0.1)


      let barHeight = (height - 32)/data.length;

      let barGroup = timeline.selectAll("g")
        .data(data)
        .enter()
        .append("g")
        .classed("bar_group", true)
        .on("mouseover", function(d, i) {
            onionSkin(i);
        })
        .on("click", function(d, i) {
            select(i);
        })

      barGroup.append("rect")
        .attr("x", x(0))
        .attr("y", function(d, i) {
            return y(i);
        })
        .attr("width", parseInt(timeline.style("width"))-margin.right)
        .attr("height", barHeight)
        .attr("class", function(d, ix) {
            return "barback d"+ix;
        });

      barGroup.append("rect")
        .attr("x", x(0) - 1)
        .attr("y", function(d, i) {
            return y(i);
        })
        .attr("class", "bar")
        .attr("width", function(d) {
            let dist = getDistance(d, false);
            console.log(dist);
            return x(dist) - x(0);
        })
        .attr("height", barHeight);

      // DATALIST - list data and provide main UI

      let datalistItem = datalist.selectAll('li')
            .data(data)
            .enter()
            .append('li')
            .on('mouseover', function(d, i) {
                onionSkin(i);
            })
            .on('click', function(d, i) {
                select(i);
            })
            .attr("class", function(d, ix) {
                return "dli"+ix;
            });

      datalistItem.append('span')
            .classed('timestamp', true)
            .text( function(d) {
                return formatTime(d.Timestamp_Minutes)
            });


      datalistItem.append('span')
            .text( function(d) {

                let limbMoved = whichLimbMoved(d);

                if (limbMoved === null) {
                    console.log('warning: ')
                    console.log(d);
                }

                return (limbMoved != null) ? formatLimb(limbMoved) : 'N/A';
            });

      datalistItem.append('div')
            .classed('arrow', true)
            .style('transform', function(d, i) {
                let limbMoved = whichLimbMoved(d);
                let x = n(d[limbMoved+'_X_Delta']);
                let y = n(d[limbMoved+'_Y_Delta']);

                let degrees = (-1)*(Math.atan(x / y)*(180/Math.PI)).toFixed(2);
                return 'rotate('+degrees+'deg)';
            });

      datalistItem.append('span')
            .classed('distance', true)
            .html( function(d) {
                return getDistance(d, true);
            });

      // CREATE ROUTE MAP AND DYNAMIC COMPOSITE

      background2.on('mouseover', function() {
          d3.selectAll('.onion').transition().duration(200).style('opacity', 1);
      })

      // add the images of logan climbing the wall
      background2.selectAll('img.position')
            .data(data)
            .enter()
            .append('img')
            .attr('class', function(d, i) {
                return 'position onion d'+i;
            })
            .style('top', function(d) {
                return (d.Img_Pos_Y_px*resize_ratio)+'px';
            })
            .style('left', function(d) {
                return (d.Img_Pos_X_px*resize_ratio)+'px';
            })
            .style('width', function(d) {
                return (d.Img_Width_px*resize_ratio)+'px';
            })
            .style('height', function(d) {
                return (d.Img_Height_px*resize_ratio)+'px';
            })
            .style('z-index', function(d, i) {
                return 120-i;
            })
            .attr('src', function(d, i) {
                return 'images/sequence_4/'+(120-i)+'.png';
            });


      // interate through each set of limbs and draw a corresponding line
      for (var i in limbs) {

          // get pixel-value positions
          function x_pos(d) {
              return n( d[limbs[i]+'_X'] )*resize_ratio;
          }

          function y_pos(d) {
              return n( d[limbs[i]+'_Y'] )*resize_ratio;
          }

          function x_delta(d) {
              return n( d[limbs[i]+'_X_Delta'] )*resize_ratio;
          }

          function y_delta(d) {
              return n( d[limbs[i]+'_Y_Delta'] )*resize_ratio;
          }

          let line = svg.selectAll('line.'+limbs[i])
            .data(data)
            .enter()
            .append('line')
            .attr('class', function(d, ix) {
                return limbs[i]+' onion d'+ix;
            })
            .attr('x1', function(d) {
                return x_pos(d);
            })
            .attr('x2', function(d) {
                return ( x_pos(d) - x_delta(d) );
            })
            .attr('y1', function(d) {
                return y_pos(d);
            })
            .attr('y2', function(d) {
                return ( y_pos(d) - y_delta(d) );
            });

          let circle = svg.selectAll('circle.'+limbs[i])
            .data(data)
            .enter()
            .append('circle')
            .attr('cx', function(d) {
                return x_pos(d);
            })
            .attr('cy', function(d) {
                return y_pos(d);
            })
            .attr('r', 2)
            .attr('class', function(d , ix) {
                return 'onion d'+ix;
            });
      }

    });

    function getDistance(d, format) {

        let limbMoved = whichLimbMoved(d);

        // limb moved returns null if 0s
        if ( limbMoved != null ) {

            let x = n(d[limbMoved+'_X_Delta']);
            let y = n(d[limbMoved+'_Y_Delta']);

            return format ? formatDistance(x, y, n(d['Pixel_Foot'])) : calcDistance(x, y, n(d['Pixel_Foot']));

        }   else {

            return format ? 0+"&prime; "+0+"&Prime;" : 0;
        }

    }

    function formatTime(rawTime) {
        // input is formatted as minutes in decimal (eg 3.456)
        // converts decimal place to seconds and formats to standard display (12:00)
        let minutes = Math.floor(rawTime);
        let seconds = rawTime - minutes;
            seconds = Math.round((seconds*60), 0);
            seconds = seconds<10 ? '0'+seconds : seconds;

        return minutes + ':' + seconds;
    }

    function formatLimb(limb) {

        switch (limb) {
            case 'RF':
                limbText = "Right Foot";
                break;
            case 'LF':
                limbText = "Left Foot";
                break;
            case 'RH':
                limbText = "Right Hand";
                break;
            case 'LH':
                limbText = "Left Hand";
                break;
        }

        return limbText;

    }

    function calcDistance(x, y, pixelFoot) {

        x = Math.abs(x);
        y = Math.abs(y);
        let dist = Math.sqrt(Math.pow(x, 2)+Math.pow(y, 2));
            dist = dist/pixelFoot;

        return dist;
    }

    function formatDistance(x, y, pixelFoot) {

        let dist = calcDistance(x, y, pixelFoot);

        let feet = Math.floor(dist);

        let inches = dist - feet;
            inches = Math.round((inches*12), 0);

        return feet+'&prime; '+inches+'&Prime;';

    }

    function whichLimbMoved(d) {

        let limbMoved = null;

        // which appendage moved? The one with a delta not equal to zero
        limbs.forEach( function(limb, limb_index) {
            if (n(d[limb+'_X_Delta']) != 0  ||  n(d[limb+'_Y_Delta']) != 0) {
                limbMoved = limb;
            }
        });

        return limbMoved;
    }

    // current height is the distance of the lowest foot from the ground
    function currentHeight(d) {

        // get the position of the lowest limb
        let lowerLimbPos = d.LF_Y > d.RF_Y ? d.LF_Y : d.RF_Y;
        let heightFromGround = (real_height - lowerLimbPos)/d.Pixel_Foot;
        return heightFromGround.toFixed(2);

    }

    // store a selected range of movements
    let selected = [null, null];

    function select(ix) {

        // a user selects list item ix
        // it remains highlighted

        // case 1: no logans are selected [null, null]
        // case 2: one logan is selected [ix, null]
        // case 3: two logans are selected [ix, ix]

        if (selected[0] != ix && selected[1] != ix) {
            // if the mouse is not clicking a selected logan...
            if (selected[0] === null) {
                // and if no logans are selected, select that logan...
                selected[0] = ix;
                d3.selectAll('.onion').style('opacity', 0);
                d3.select('.dli'+ix).style('background-color', 'white');
                d3.selectAll('.d'+ix).style('opacity', 1);

                // selecting a logan from the chart scrolls the left side up
                let scrollDistance = ix * parseInt(d3.select('#datalist li').style('height'));
                document.querySelector('#datalist').scrollTo(0,scrollDistance);

            } else if (selected[0] != null && selected[1] === null) {
                // if one logan is selected but the second is not...
                // select the range
                selected[1] = ix;

            } else {
                // otherwise, clear the selection
                clearSelection();
            }

        } else {
             // if the mouse is clicking a selected logan...
             clearSelection();
        }

    }

    function clearSelection() {
        selected = [null, null];
        d3.selectAll('li').style('background-color', 'transparent');
        d3.selectAll('.onion').style('opacity', 1);
    }


    function onionSkin(ix) {

        if (selected[0] != null && selected[1] === null) {
            // if one logan is selected but a second logan is not selected
            console.log('selected: '+selected);

            // add logans to current range
            let diff = (selected[0] > ix) ? selected[0] - ix : ix - selected[0];
            let max = 119;
            let min = 0;

            for (i=min; i < diff; i++) {

                let hoverIX = (selected[0] > ix) ? ix + i : selected[0] + i;
                d3.select('.dli'+hoverIX).style('background-color', 'rgba(255,255,255,0.5)');
                d3.selectAll('.d'+hoverIX).style('opacity', .5)
            }

            // remove logans not included in range
            let greater_than = (selected[0] > ix) ? selected[0] : ix;

            let lesser_than = (selected[0] > ix) ? ix : selected[0];

            for (i = min; i < lesser_than; i++) {
                d3.selectAll('.d'+i).style('opacity', 0);
                d3.select('.dli'+i).style('background-color', 'transparent');
            }
            for (i = greater_than; i < max; i++ ) {
                d3.selectAll('.d'+i).style('opacity', 0);
                d3.select('.dli'+i).style('background-color', 'transparent');
            }

                // highlight every item between 'selected' and 'ix'
                // selection math:
                    // total distance traveled
                    // time between
                    // distance from ground?
        } else {
            // what to do when something isn't selected
                // (current onionSkin behavior)
        }

    }

    </script>
</body>
